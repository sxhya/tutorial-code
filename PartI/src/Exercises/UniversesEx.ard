\import Basics (-)
\import Indexed (<, Empty, T, pmap, unit)
\import Paths (inv, transport)
\import Universes
\import Proofs(absurd, inl, inr, ||)

-- 1. Calculate levels in each of the the invocations of 'id''' below.
--    Specify explicitly result types for all idTest*.

\func id'' {A : \Type} (a : A) => a

\func idTest1 : \Pi (A : \Type \lp) -> A -> A => id'' (id'' id)
\func idTest2 : \Type \lp -> \Type \lp => id'' Maybe
\func idTest3 : \Type (\suc \lp) => id'' Functor
\func idTest4 : \Type (\suc \lp) => id'' (Functor Maybe)
\func idTest5 (f : \Pi {A B : \Set} -> (A -> B) -> Maybe A -> Maybe B) : \Type \lp => id'' (Functor Maybe f)

-- 2. Define 'div' via 'Nat-ind'.

\func T<0=false {l : Nat} (a : T (l < 0)) : Empty | {0}, ()
\func Nat-ind-helper (E : Nat -> \Type)
                     (r : \Pi (n : Nat) -> (\Pi (k : Nat) -> T (k < n) -> E k) -> E n)
                     {n k : Nat} (A : T (k < suc n)) : E k \elim n
  | 0 => \case \elim k, A \with {
    | 0, _ => r 0 (\lam k A => absurd (T<0=false A))
    | suc k1, A => absurd (T<0=false A)
  }
  | suc n => \case T-suc A \with {
    | inl p => Nat-ind-helper E r p
    | inr q => transport E (inv q) (r (suc n) (\lam k A => Nat-ind-helper E r A))
  }
  \where {
    \func T-suc {n k : Nat} (A : T (k < suc n)) : T (k < n) Proofs.|| (k = n) \elim n
      | 0 => \case \elim k, A : T (k < 1) \with {
        | 0, unit => Proofs.inr idp
        | suc k, t => absurd (T<0=false t)
      }
      | suc n => \case \elim k, A : T (k < suc (suc n)) \with {
        | 0, A => Proofs.inl unit
        | suc k, A1 => \case T-suc A1 \with {
          | Proofs.inl a => Proofs.inl a
          | Proofs.inr b => Proofs.inr (pmap suc b)
        }
      }
  }
\func Nat-ind (E : Nat -> \Type)
              (r : \Pi (n : Nat) -> (\Pi (k : Nat) -> T (k < n) -> E k) -> E n)
              (n : Nat) : E n => Nat-ind-helper E r n<sucn

\open n-k<n (n<sucn)

\func n-k<n (n k : Nat) (A : T (0 < k)) : T (n - k < n) Proofs.|| (n = 0) \elim n, k
  | 0, suc k => Proofs.inr idp
  | suc n, suc k => Proofs.inl \case \elim k, n-k<n n k \with {
    | 0, _ => transport (\lam x => T (x < suc n)) (inv n-0) n<sucn
    | suc k1, _x => \case _x unit \with {
      | inl p => <-trans p n<sucn
      | inr q => transport (\lam x => T (x - suc k1 < suc x)) (inv q) unit
    }
  } \where {
  \func <-trans {n m k : Nat} (A0 : T (n < m)) (A1 : T (m < k)) : T (n < k)
    | {0}, {0}, {0}, (), A1
    | {0}, {suc m}, {0}, unit, ()
    | {0}, {suc m}, {suc k}, unit, A1 => unit
    | {suc n}, {0}, {0}, (), A1
    | {suc n}, {suc m}, {suc k}, A0, A1 => <-trans A0 A1

  \func n-0 {n : Nat} : n - 0 = n | {0} => idp | {suc n} => idp

  \func n<sucn {n : Nat} : T (n < suc n) | {0} => unit | {suc n} => n<sucn
}
\func div (n k : Nat) (p : T (0 < k)) : Nat => Nat-ind (\lam _ => Nat) (\lam n f => \case n-k<n n k p \with {
  | inl p1 => \case n < k \with {
    | true => 0
    | false => suc (f (n - k) p1)
  }
  | inr q => 0
}) n

-- 3. Prove the following induction principle for lists:

\func length {A : \Type} (xs : List A) : Nat
  | nil => 0
  | cons _ xs => suc (length xs)

\func List-ind
  {A : \Type}
  (E : List A -> \Type)
  (r : \Pi (xs : List A) -> (\Pi (ys : List A) -> T (length ys < length xs) -> E ys) -> E xs)
  (xs : List A) : E xs => {?}

-- 4. Implement function 'filter' and prove that it is correct, that is that the following holds:
--    * 'filter p xs' is a sublist of 'xs'
--    * All elements of 'filter p xs' satisfy the predicate 'p'
--    * Any sublist of 'xs' with this property is a sublist of 'filter p xs'
