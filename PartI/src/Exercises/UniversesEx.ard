\import Basics (-)
\import Exercises.CaseEx (mod-view)
\import Indexed (<, <-vs-<=, <=, Empty, T, fzero, pmap, unit)
\import Logic (byLeft, byRight, ||)
\import Paths.Meta
\import Universes
\import Proofs(absurd)

-- 1. Calculate levels in each of the the invocations of 'id''' below.
--    Specify explicitly result types for all idTest*.

\func id'' {A : \Type} (a : A) => a

\func idTest1 : \Pi (A : \Type \lp) -> A -> A => id'' (id'' id)
\func idTest2 : \Type \lp -> \Type \lp => id'' Maybe
\func idTest3 : \Type (\suc \lp) => id'' Functor
\func idTest4 : \Type (\suc \lp) => id'' (Functor Maybe)
\func idTest5 (f : \Pi {A B : \Set} -> (A -> B) -> Maybe A -> Maybe B) : \Type \lp => id'' (Functor Maybe f)

-- 2. Define 'div' via 'Nat-ind'.

\func T<0=false {l : Nat} (a : T (l < 0)) : Empty | {0}, ()

\func T=0 {l : Nat} (a : T (l <= 0)) : l = 0 \elim l | 0 => idp | suc l => absurd a

\func T-suc {n k : Nat} (A : T (k < suc n)) : T (k < n) Proofs.|| (k = n) \elim n
  | 0 => \case \elim k, A : T (k < 1) \with {
    | 0, unit => Proofs.inr idp
    | suc k, t => absurd (T<0=false t)
  }
  | suc n => \case \elim k, A : T (k < suc (suc n)) \with {
    | 0, A => Proofs.inl unit
    | suc k, A1 => \case T-suc A1 \with {
      | Proofs.inl a => Proofs.inl a
      | Proofs.inr b => Proofs.inr (pmap suc b)
    }
  }

\func T-suc2 {n k : Nat} (A : T (k <= suc n)) : T (k < suc n) Proofs.|| (k = suc n) => T-suc {suc n} {k} (rewrite <-vs-<= A)

\func <=-refl {n : Nat} : T (n <= n) \elim n | 0 => unit | suc n => <=-refl

\func Nat-ind-helper (E : Nat -> \Type)
                     (r : \Pi (n : Nat) -> (\Pi (k : Nat) -> T (k < n) -> E k) -> E n)
                     (n k : Nat) (A : T (k <= n)) : E k \elim n
  | 0 => rewrite (T=0 A) (r 0 (\lam (k : Nat) (p : T (k < 0)) => absurd (T<0=false p)))
  | suc n => \case T-suc2 A \return E k \with {
    | Proofs.inl a => Nat-ind-helper E r n k (rewriteI <-vs-<= a)
    | Proofs.inr b => \let result => r (suc n) (\lam k C => Nat-ind-helper E r n k (rewriteI <-vs-<= C)) \in rewrite b result
  }

\func Nat-ind (E : Nat -> \Type)
              (r : \Pi (n : Nat) -> (\Pi (k : Nat) -> T (k < n) -> E k) -> E n)
              (n : Nat) : E n => Nat-ind-helper E r n n <=-refl

\func <-suc {n k : Nat} (A : T (n < k)) : T (n < suc k) | {0}, {suc k}, unit => unit | {suc n}, {suc k}, A => <-suc A

\func n<sucn {n : Nat} : T (n < suc n) | {0} => unit | {suc n} => n<sucn

\func sum (n : Nat) (f : \Pi (k : Nat) -> T (k < n) -> Nat) : Nat
  | 0, f => 1
  | suc n, f => f n n<sucn Nat.+ sum n (\lam k A => f k (<-suc A))

\func sum2 (n : Nat) => sum n (\lam k A => k)
\func foo (n : Nat) : Nat =>
  Nat-ind (\lam _ => Nat) {?}  n

\func div (n k : Nat) (p : T (0 < k)) : Nat => {?}

-- 3. Prove the following induction principle for lists:

\func length {A : \Type} (xs : List A) : Nat
  | nil => 0
  | cons _ xs => suc (length xs)

\func List-ind
  {A : \Type}
  (E : List A -> \Type)
  (r : \Pi (xs : List A) -> (\Pi (ys : List A) -> T (length ys < length xs) -> E ys) -> E xs)
  (xs : List A) : E xs => {?}

-- 4. Implement function 'filter' and prove that it is correct, that is that the following holds:
--    * 'filter p xs' is a sublist of 'xs'
--    * All elements of 'filter p xs' satisfy the predicate 'p'
--    * Any sublist of 'xs' with this property is a sublist of 'filter p xs'
